apiVersion: compliance.openshift.io/v1alpha1
kind: CustomRule
metadata:
  name: custom-rule-enable-nonroot-feature-gate-cel
  namespace: openshift-compliance
spec:
  checkType: Platform
  instructions: |-
    Verify that the nonRoot feature gate is enabled for the hyperconverged resource.

    Audit:
      Run the following command:
      $ oc get hyperconverged kubevirt-hyperconverged -n openshift-cnv -o jsonpath='{.spec.featureGates.nonRoot}'
      The output should be "true".

    Remediation:
      Enable nonRoot by setting its value to True.
  rationale: >
    Running workloads as root can lead to privilege escalation and unauthorized administrative
    access. Enabling the nonRoot feature gate ensures that KubeVirt workloads run with only the
    minimal privileges required, thereby reducing the risk of unintended or malicious privilege escalation.
  title: Ensure nonRoot Feature Gate is Enabled
  scannerType: CEL
  id: enable_nonroot_feature_gate_cel
  description: >
    Ensure that the hyperconverged resource (kubevirt-hyperconverged in the openshift-cnv namespace)
    has the nonRoot feature gate enabled. By default, KubeVirt workloads run in nonRoot mode.
  severity: high
  expression: >
    hco.spec.featureGates.nonRoot == true
  inputs:
    - name: hco
      apiGroup: hco.kubevirt.io
      type: KubeGroupVersionResource
      version: v1beta1
      # The "resource" field below includes the object name (kubevirt-hyperconverged)
      # in the format "resourceName/objectName" to target the specific instance.
      resource: hyperconverged/kubevirt-hyperconverged
      namespace: openshift-cnv
  errorMessage: "The nonRoot feature gate is not enabled for the hyperconverged resource."
---
kind: CustomRule
apiVersion: compliance.openshift.io/v1alpha1
metadata:
  name: custom-rule-configure-network-policies-namespaces-cel
  namespace: openshift-compliance
spec:
  rationale: "Running different applications on the same Kubernetes cluster creates a risk of one compromised application attacking a neighboring application. Network segmentation is important to ensure that containers can communicate only with those they are supposed to. When a network policy is introduced to a given namespace, all traffic not allowed by the policy is denied. However, if there are no network policies in a namespace all traffic will be allowed into and out of the pods in that namespace."
  checkType: Platform
  instructions: |-
    Verify that the every non-control plane namespace has an appropriate
    NetworkPolicy.
    To get all the non-control plane namespaces, you can do the
    following command $ oc get  namespaces -o json | jq '[.items[] | select((.metadata.name | startswith("openshift") | not) and (.metadata.name | startswith("kube-") | not) and .metadata.name != "default" and (true)) | .metadata.name ]'
    To get all the non-control plane namespaces with a NetworkPolicy, you can do the
    following command $ oc get --all-namespaces networkpolicies -o json | jq '[.items[] | select((.metadata.namespace | startswith("openshift") | not) and (.metadata.namespace | startswith("kube-") | not) and .metadata.namespace != "default" and (true)) | .metadata.namespace] | unique'
    Namespaces matching the variable ocp4-var-network-policies-namespaces-exempt-regex regex are excluded from this check.
    Make sure that the namespaces displayed in the commands of the commands match.
    Is it the case that Namespaced Network Policies needs review?
  title: Ensure that application Namespaces have Network Policies defined.
  scannerType: CEL
  id: content_rule_configure_network_policies_namespaces
  description: Use network policies to isolate traffic in your cluster network.
  severity: high
  expression: >
    size(nl.items) == 0 ||
    size(
      nl.items
      .filter(ns, !ns.metadata.name.matches(e.value))
      .filter(ns, npl.items.exists(np, np.metadata.namespace == ns.metadata.name))
    ) == size(nl.items.filter(ns, !ns.metadata.name.matches(e.value)))
  inputs:
    - name: nl
      type: KubeGroupVersionResource
      apiGroup: ""
      version: v1
      resource: namespaces
    - name: npl
      type: KubeGroupVersionResource
      apiGroup: networking.k8s.io
      version: v1
      resource: networkpolicies
    - name: e
      type: KubeGroupVersionResource
      apiGroup: compliance.openshift.io
      version: v1alpha1
      resource: variables/ocp4-var-network-policies-namespaces-exempt-regex
      namespace: openshift-compliance
  errorMessage: "Application Namespaces do not have Network Policies defined."
---
apiVersion: compliance.openshift.io/v1alpha1
kind: CustomRule
metadata:
  name: custom-rule-etcd-cert-file-cel
  namespace: openshift-compliance
spec:
  id: content_rule_etcd_cert_file
  checkType: Platform
  instructions: |-
    Run the following command:
    oc get -nopenshift-etcd cm etcd-pod -oyaml | grep -E "\-\-cert-file=/etc/kubernetes/static-pod-certs/secrets/etcd-all-[a-z]+/etcd-serving-NODE_NAME.crt"
    Verify that there is a certificate configured.
    Is it the case that the etcd client certificate is not configure
  rationale:
    Without cryptographic integrity protections, information can be altered
    by unauthorized users without detection.
  title: Ensure the etcd client certificate is set
  scannerType: CEL
  description: |-
    To ensure the etcd service is serving TLS to clients, make sure the etcd-pod* ConfigMaps in the openshift-etcd namespace contain the following argument for the etcd binary in the etcd pod:
    --cert-file=/etc/kubernetes/static-pod-certs/secrets/etcd-all-[a-z]+/etcd-serving-NODE_NAME.crt
    . Note that the
    [a-z]+
    is being used since the directory might change between OpenShift versions.
  severity: medium
  expression: cm.data["pod.yaml"].parseYAML().spec.containers.exists(c, c.command.exists(x, x.matches(r'--cert-file=/.*\.crt') ))
  # The expression above checks the following resource "oc get -nopenshift-etcd cm etcd-pod -oyaml"
  inputs:
    - name: cm
      namespace: openshift-etcd
      type: KubeGroupVersionResource
      apiGroup: ""
      version: v1
      resource: configmaps/etcd-pod
  errorMessage: There is no pod with executing a command '--cert-file='
